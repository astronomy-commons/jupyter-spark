// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { PathExt } from '@jupyterlab/coreutils';
import { UUID } from '@lumino/coreutils';
import { each, find } from '@lumino/algorithm';
import { PromiseDelegate } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
import { Widget } from '@lumino/widgets';
import * as React from 'react';
import { showDialog, Dialog } from './dialog';
/**
 * The default implementation for a session context object.
 */
export class SessionContext {
    /**
     * Construct a new session context.
     */
    constructor(options) {
        var _a, _b, _c, _d;
        this._path = '';
        this._name = '';
        this._type = '';
        this._prevKernelName = '';
        this._isDisposed = false;
        this._disposed = new Signal(this);
        this._session = null;
        this._ready = new PromiseDelegate();
        this._initializing = false;
        this._initPromise = new PromiseDelegate();
        this._isReady = false;
        this._kernelChanged = new Signal(this);
        this._sessionChanged = new Signal(this);
        this._statusChanged = new Signal(this);
        this._connectionStatusChanged = new Signal(this);
        this._iopubMessage = new Signal(this);
        this._unhandledMessage = new Signal(this);
        this._propertyChanged = new Signal(this);
        this._dialog = null;
        this._busyDisposable = null;
        this.sessionManager = options.sessionManager;
        this.specsManager = options.specsManager;
        this._path = (_a = options.path, (_a !== null && _a !== void 0 ? _a : UUID.uuid4()));
        this._type = (_b = options.type, (_b !== null && _b !== void 0 ? _b : ''));
        this._name = (_c = options.name, (_c !== null && _c !== void 0 ? _c : ''));
        this._setBusy = options.setBusy;
        this._kernelPreference = (_d = options.kernelPreference, (_d !== null && _d !== void 0 ? _d : {}));
    }
    /**
     * The current session connection.
     */
    get session() {
        var _a;
        return _a = this._session, (_a !== null && _a !== void 0 ? _a : null);
    }
    /**
     * The session path.
     *
     * #### Notes
     * Typically `.session.path` should be used. This attribute is useful if
     * there is no current session.
     */
    get path() {
        return this._path;
    }
    /**
     * The session type.
     *
     * #### Notes
     * Typically `.session.type` should be used. This attribute is useful if
     * there is no current session.
     */
    get type() {
        return this._type;
    }
    /**
     * The session name.
     *
     * #### Notes
     * Typically `.session.name` should be used. This attribute is useful if
     * there is no current session.
     */
    get name() {
        return this._name;
    }
    /**
     * A signal emitted when the kernel connection changes, proxied from the session connection.
     */
    get kernelChanged() {
        return this._kernelChanged;
    }
    /**
     * A signal emitted when the session connection changes.
     */
    get sessionChanged() {
        return this._sessionChanged;
    }
    /**
     * A signal emitted when the kernel status changes, proxied from the kernel.
     */
    get statusChanged() {
        return this._statusChanged;
    }
    /**
     * A signal emitted when the kernel status changes, proxied from the kernel.
     */
    get connectionStatusChanged() {
        return this._connectionStatusChanged;
    }
    /**
     * A signal emitted for iopub kernel messages, proxied from the kernel.
     */
    get iopubMessage() {
        return this._iopubMessage;
    }
    /**
     * A signal emitted for an unhandled kernel message, proxied from the kernel.
     */
    get unhandledMessage() {
        return this._unhandledMessage;
    }
    /**
     * A signal emitted when a session property changes, proxied from the current session.
     */
    get propertyChanged() {
        return this._propertyChanged;
    }
    /**
     * The kernel preference of this client session.
     *
     * This is used when selecting a new kernel, and should reflect the sort of
     * kernel the activity prefers.
     */
    get kernelPreference() {
        return this._kernelPreference;
    }
    set kernelPreference(value) {
        this._kernelPreference = value;
    }
    /**
     * Whether the context is ready.
     */
    get isReady() {
        return this._isReady;
    }
    /**
     * A promise that is fulfilled when the context is ready.
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * The display name of the current kernel, or a sensible alternative.
     *
     * #### Notes
     * This is a convenience function to have a consistent sensible name for the
     * kernel.
     */
    get kernelDisplayName() {
        var _a, _b, _c, _d;
        let kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel &&
            !this.isReady &&
            this.kernelPreference.canStart !== false &&
            this.kernelPreference.shouldStart !== false) {
            return 'Kernel';
        }
        if (!kernel) {
            return 'No Kernel!';
        }
        return (_d = (_c = (_b = this.specsManager.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[kernel.name]) === null || _c === void 0 ? void 0 : _c.display_name, (_d !== null && _d !== void 0 ? _d : kernel.name));
    }
    /**
     * A sensible status to display
     *
     * #### Notes
     * This combines the status and connection status into a single status for
     * the user.
     */
    get kernelDisplayStatus() {
        var _a, _b, _c, _d, _e;
        let kernel = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel &&
            !this.isReady &&
            this.kernelPreference.canStart !== false &&
            this.kernelPreference.shouldStart !== false) {
            return 'initializing';
        }
        return (_e = (((_b = kernel) === null || _b === void 0 ? void 0 : _b.connectionStatus) === 'connected'
            ? (_c = kernel) === null || _c === void 0 ? void 0 : _c.status : (_d = kernel) === null || _d === void 0 ? void 0 : _d.connectionStatus), (_e !== null && _e !== void 0 ? _e : ''));
    }
    /**
     * The name of the previously started kernel.
     */
    get prevKernelName() {
        return this._prevKernelName;
    }
    /**
     * Test whether the context is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * A signal emitted when the poll is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Dispose of the resources held by the context.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._session) {
            if (this.kernelPreference.shutdownOnDispose) {
                // Fire and forget the session shutdown request
                this._session.shutdown().catch(reason => {
                    console.error(`Kernel not shut down ${reason}`);
                });
            }
            // Dispose the session connection
            this._session.dispose();
            this._session = null;
        }
        if (this._dialog) {
            this._dialog.dispose();
        }
        if (this._busyDisposable) {
            this._busyDisposable.dispose();
            this._busyDisposable = null;
        }
        Signal.clearData(this);
    }
    /**
     * Change the current kernel associated with the session.
     */
    async changeKernel(options = {}) {
        await this.initialize();
        if (this.isDisposed) {
            throw new Error('Disposed');
        }
        return this._changeKernel(options);
    }
    /**
     * Kill the kernel and shutdown the session.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    async shutdown() {
        var _a;
        return (_a = this._session) === null || _a === void 0 ? void 0 : _a.shutdown();
    }
    /**
     * Initialize the session context
     *
     * @returns A promise that resolves with whether to ask the user to select a kernel.
     *
     * #### Notes
     * If a server session exists on the current path, we will connect to it.
     * If preferences include disabling `canStart` or `shouldStart`, no
     * server session will be started.
     * If a kernel id is given, we attempt to start a session with that id.
     * If a default kernel is available, we connect to it.
     * Otherwise we ask the user to select a kernel.
     */
    async initialize() {
        if (this._initializing) {
            return this._initPromise.promise;
        }
        this._initializing = true;
        let manager = this.sessionManager;
        await manager.ready;
        let model = find(manager.running(), item => {
            return item.path === this._path;
        });
        if (model) {
            try {
                let session = manager.connectTo({ model });
                this._handleNewSession(session);
            }
            catch (err) {
                void this._handleSessionError(err);
                return Promise.reject(err);
            }
        }
        const needsSelection = await this._startIfNecessary();
        if (!needsSelection) {
            this._isReady = true;
            this._ready.resolve(undefined);
        }
        this._initPromise.resolve(needsSelection);
        return needsSelection;
    }
    /**
     * Start the session if necessary.
     *
     * @returns Whether to ask the user to pick a kernel.
     */
    async _startIfNecessary() {
        var _a;
        let preference = this.kernelPreference;
        if (this.isDisposed || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) ||
            preference.shouldStart === false ||
            preference.canStart === false) {
            // Not necessary to start a kernel
            return false;
        }
        let options;
        if (preference.id) {
            options = { id: preference.id };
        }
        else {
            let name = SessionContext.getDefaultKernel({
                specs: this.specsManager.specs,
                sessions: this.sessionManager.running(),
                preference
            });
            if (name) {
                options = { name };
            }
        }
        if (options) {
            try {
                await this._changeKernel(options);
                return false;
            }
            catch (err) {
                /* no-op */
            }
        }
        // Always fall back to selecting a kernel
        return true;
    }
    /**
     * Change the kernel.
     */
    async _changeKernel(options = {}) {
        var _a;
        if (this.isDisposed) {
            throw new Error('Disposed');
        }
        let session = this._session;
        if (session && ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.status) !== 'dead') {
            try {
                return session.changeKernel(options);
            }
            catch (err) {
                void this._handleSessionError(err);
                throw err;
            }
        }
        else {
            return this._startSession(options);
        }
    }
    /**
     * Start a session and set up its signals.
     */
    async _startSession(model = {}) {
        if (this.isDisposed) {
            throw 'Client session is disposed.';
        }
        try {
            const session = await this.sessionManager.startNew({
                path: this._path,
                type: this._type,
                name: this._name,
                kernel: model
            });
            return this._handleNewSession(session);
        }
        catch (err) {
            void this._handleSessionError(err);
            throw err;
        }
    }
    /**
     * Handle a new session object.
     */
    _handleNewSession(session) {
        var _a, _b;
        if (this.isDisposed) {
            throw Error('Disposed');
        }
        if (!this._isReady) {
            this._isReady = true;
            this._ready.resolve(undefined);
        }
        if (this._session) {
            this._session.dispose();
        }
        this._session = session;
        this._prevKernelName = (_b = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : ''));
        session.disposed.connect(this._onSessionDisposed, this);
        session.propertyChanged.connect(this._onPropertyChanged, this);
        session.kernelChanged.connect(this._onKernelChanged, this);
        session.statusChanged.connect(this._onStatusChanged, this);
        session.connectionStatusChanged.connect(this._onConnectionStatusChanged, this);
        session.iopubMessage.connect(this._onIopubMessage, this);
        session.unhandledMessage.connect(this._onUnhandledMessage, this);
        if (session.path !== this._path) {
            this._onPropertyChanged(session, 'path');
        }
        if (session.name !== this._name) {
            this._onPropertyChanged(session, 'name');
        }
        if (session.type !== this._type) {
            this._onPropertyChanged(session, 'type');
        }
        // Any existing kernel connection was disposed above when the session was
        // disposed, so the oldValue should be null.
        this._kernelChanged.emit({
            oldValue: null,
            newValue: session.kernel,
            name: 'kernel'
        });
        return session.kernel;
    }
    /**
     * Handle an error in session startup.
     */
    async _handleSessionError(err) {
        let text = await err.response.text();
        let message = err.message;
        try {
            message = JSON.parse(text)['traceback'];
        }
        catch (err) {
            // no-op
        }
        let dialog = (this._dialog = new Dialog({
            title: 'Error Starting Kernel',
            body: React.createElement("pre", null, message),
            buttons: [Dialog.okButton()]
        }));
        await dialog.launch();
        this._dialog = null;
    }
    /**
     * Handle a session termination.
     */
    _onSessionDisposed() {
        if (this._session) {
            this._session.dispose();
            const oldValue = this._session;
            this._session = null;
            const newValue = this._session;
            this._sessionChanged.emit({ name: 'session', oldValue, newValue });
        }
    }
    /**
     * Handle a change to a session property.
     */
    _onPropertyChanged(sender, property) {
        switch (property) {
            case 'path':
                this._path = sender.path;
                break;
            case 'name':
                this._name = sender.name;
                break;
            case 'type':
                this._type = sender.type;
                break;
            default:
                throw new Error(`unrecognized property ${property}`);
        }
        this._propertyChanged.emit(property);
    }
    /**
     * Handle a change to the kernel.
     */
    _onKernelChanged(sender, args) {
        this._kernelChanged.emit(args);
    }
    /**
     * Handle a change to the session status.
     */
    _onStatusChanged(sender, status) {
        // Set that this kernel is busy, if we haven't already
        // If we have already, and now we aren't busy, dispose
        // of the busy disposable.
        if (this._setBusy) {
            if (status === 'busy') {
                if (!this._busyDisposable) {
                    this._busyDisposable = this._setBusy();
                }
            }
            else {
                if (this._busyDisposable) {
                    this._busyDisposable.dispose();
                    this._busyDisposable = null;
                }
            }
        }
        // Proxy the signal
        this._statusChanged.emit(status);
    }
    /**
     * Handle a change to the session status.
     */
    _onConnectionStatusChanged(sender, status) {
        // Proxy the signal
        this._connectionStatusChanged.emit(status);
    }
    /**
     * Handle an iopub message.
     */
    _onIopubMessage(sender, message) {
        this._iopubMessage.emit(message);
    }
    /**
     * Handle an unhandled message.
     */
    _onUnhandledMessage(sender, message) {
        this._unhandledMessage.emit(message);
    }
}
/**
 * A namespace for `SessionContext` statics.
 */
(function (SessionContext) {
    /**
     * Get the default kernel name given select options.
     */
    function getDefaultKernel(options) {
        return Private.getDefaultKernel(options);
    }
    SessionContext.getDefaultKernel = getDefaultKernel;
})(SessionContext || (SessionContext = {}));
/**
 * The default implementation of the client sesison dialog provider.
 */
export const sessionContextDialogs = {
    /**
     * Select a kernel for the session.
     */
    async selectKernel(sessionContext) {
        var _a, _b, _c, _d;
        if (sessionContext.isDisposed) {
            return Promise.resolve();
        }
        // If there is no existing kernel, offer the option
        // to keep no kernel.
        let label = 'Cancel';
        if (!((_b = (_a = sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel)) {
            label = 'No Kernel';
        }
        const buttons = [
            Dialog.cancelButton({ label }),
            Dialog.okButton({ label: 'Select' })
        ];
        let dialog = new Dialog({
            title: 'Select Kernel',
            body: new Private.KernelSelector(sessionContext),
            buttons
        });
        const result = await dialog.launch();
        if (sessionContext.isDisposed || !result.button.accept) {
            return;
        }
        let model = result.value;
        if (model === null && ((_d = (_c = sessionContext) === null || _c === void 0 ? void 0 : _c.session) === null || _d === void 0 ? void 0 : _d.kernel)) {
            return sessionContext.shutdown();
        }
        if (model) {
            await sessionContext.changeKernel(model);
        }
    },
    /**
     * Restart the session.
     *
     * @returns A promise that resolves with whether the kernel has restarted.
     *
     * #### Notes
     * If there is a running kernel, present a dialog.
     * If there is no kernel, we start a kernel with the last run
     * kernel name and resolves with `true`.
     */
    async restart(sessionContext) {
        var _a;
        await sessionContext.initialize();
        if (sessionContext.isDisposed) {
            throw new Error('session already disposed');
        }
        let kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel && sessionContext.prevKernelName) {
            await sessionContext.changeKernel({
                name: sessionContext.prevKernelName
            });
            return true;
        }
        // Bail if there is no previous kernel to start.
        if (!kernel) {
            throw new Error('No kernel to restart');
        }
        let restartBtn = Dialog.warnButton({ label: 'Restart' });
        const result = await showDialog({
            title: 'Restart Kernel?',
            body: 'Do you want to restart the current kernel? All variables will be lost.',
            buttons: [Dialog.cancelButton(), restartBtn]
        });
        if (kernel.isDisposed) {
            return false;
        }
        if (result.button.accept) {
            await kernel.restart();
            return true;
        }
        return false;
    }
};
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * A widget that provides a kernel selection.
     */
    class KernelSelector extends Widget {
        /**
         * Create a new kernel selector widget.
         */
        constructor(sessionContext) {
            super({ node: createSelectorNode(sessionContext) });
        }
        /**
         * Get the value of the kernel selector widget.
         */
        getValue() {
            let selector = this.node.querySelector('select');
            return JSON.parse(selector.value);
        }
    }
    Private.KernelSelector = KernelSelector;
    /**
     * Create a node for a kernel selector widget.
     */
    function createSelectorNode(sessionContext) {
        // Create the dialog body.
        let body = document.createElement('div');
        let text = document.createElement('label');
        text.textContent = `Select kernel for: "${sessionContext.name}"`;
        body.appendChild(text);
        let options = getKernelSearch(sessionContext);
        let selector = document.createElement('select');
        populateKernelSelect(selector, options);
        body.appendChild(selector);
        return body;
    }
    /**
     * Get the default kernel name given select options.
     */
    function getDefaultKernel(options) {
        var _a;
        let { specs, preference } = options;
        let { name, language, shouldStart, canStart, autoStartDefault } = preference;
        if (!specs || shouldStart === false || canStart === false) {
            return null;
        }
        let defaultName = autoStartDefault ? specs.default : null;
        if (!name && !language) {
            return defaultName;
        }
        // Look for an exact match of a spec name.
        for (let specName in specs.kernelspecs) {
            if (specName === name) {
                return name;
            }
        }
        // Bail if there is no language.
        if (!language) {
            return defaultName;
        }
        // Check for a single kernel matching the language.
        let matches = [];
        for (let specName in specs.kernelspecs) {
            let kernelLanguage = (_a = specs.kernelspecs[specName]) === null || _a === void 0 ? void 0 : _a.language;
            if (language === kernelLanguage) {
                matches.push(specName);
            }
        }
        if (matches.length === 1) {
            let specName = matches[0];
            console.log('No exact match found for ' +
                specName +
                ', using kernel ' +
                specName +
                ' that matches ' +
                'language=' +
                language);
            return specName;
        }
        // No matches found.
        return defaultName;
    }
    Private.getDefaultKernel = getDefaultKernel;
    /**
     * Populate a kernel select node for the session.
     */
    function populateKernelSelect(node, options) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
        let { preference, sessions, specs } = options;
        let { name, id, language, canStart, shouldStart } = preference;
        if (!specs || canStart === false) {
            node.appendChild(optionForNone());
            node.value = 'null';
            node.disabled = true;
            return;
        }
        node.disabled = false;
        // Create mappings of display names and languages for kernel name.
        let displayNames = Object.create(null);
        let languages = Object.create(null);
        for (let name in specs.kernelspecs) {
            let spec = specs.kernelspecs[name];
            displayNames[name] = spec.display_name;
            languages[name] = spec.language;
        }
        // Handle a kernel by name.
        let names = [];
        if (name && name in specs.kernelspecs) {
            names.push(name);
        }
        // Then look by language.
        if (language) {
            for (let specName in specs.kernelspecs) {
                if (name !== specName && languages[specName] === language) {
                    names.push(specName);
                }
            }
        }
        // Use the default kernel if no kernels were found.
        if (!names.length) {
            names.push(specs.default);
        }
        // Handle a preferred kernels in order of display name.
        let preferred = document.createElement('optgroup');
        preferred.label = 'Start Preferred Kernel';
        names.sort((a, b) => displayNames[a].localeCompare(displayNames[b]));
        for (let name of names) {
            preferred.appendChild(optionForName(name, displayNames[name]));
        }
        if (preferred.firstChild) {
            node.appendChild(preferred);
        }
        // Add an option for no kernel
        node.appendChild(optionForNone());
        let other = document.createElement('optgroup');
        other.label = 'Start Other Kernel';
        // Add the rest of the kernel names in alphabetical order.
        let otherNames = [];
        for (let specName in specs.kernelspecs) {
            if (names.indexOf(specName) !== -1) {
                continue;
            }
            otherNames.push(specName);
        }
        otherNames.sort((a, b) => displayNames[a].localeCompare(displayNames[b]));
        for (let otherName of otherNames) {
            other.appendChild(optionForName(otherName, displayNames[otherName]));
        }
        // Add a separator option if there were any other names.
        if (otherNames.length) {
            node.appendChild(other);
        }
        // Handle the default value.
        if (shouldStart === false) {
            node.value = 'null';
        }
        else {
            node.selectedIndex = 0;
        }
        // Bail if there are no sessions.
        if (!sessions) {
            return;
        }
        // Add the sessions using the preferred language first.
        let matchingSessions = [];
        let otherSessions = [];
        each(sessions, session => {
            var _a;
            if (language &&
                session.kernel &&
                languages[session.kernel.name] === language &&
                session.kernel.id !== id) {
                matchingSessions.push(session);
            }
            else if (((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) !== id) {
                otherSessions.push(session);
            }
        });
        let matching = document.createElement('optgroup');
        matching.label = 'Use Kernel from Preferred Session';
        node.appendChild(matching);
        if (matchingSessions.length) {
            matchingSessions.sort((a, b) => {
                return a.path.localeCompare(b.path);
            });
            each(matchingSessions, session => {
                let name = session.kernel ? displayNames[session.kernel.name] : '';
                matching.appendChild(optionForSession(session, name));
            });
        }
        let otherSessionsNode = document.createElement('optgroup');
        otherSessionsNode.label = 'Use Kernel from Other Session';
        node.appendChild(otherSessionsNode);
        if (otherSessions.length) {
            otherSessions.sort((a, b) => {
                return a.path.localeCompare(b.path);
            });
            each(otherSessions, session => {
                let name = session.kernel
                    ? displayNames[session.kernel.name] || session.kernel.name
                    : '';
                otherSessionsNode.appendChild(optionForSession(session, name));
            });
        }
    }
    Private.populateKernelSelect = populateKernelSelect;
    /**
     * Get the kernel search options given a session context and session manager.
     */
    function getKernelSearch(sessionContext) {
        return {
            specs: sessionContext.specsManager.specs,
            sessions: sessionContext.sessionManager.running(),
            preference: sessionContext.kernelPreference
        };
    }
    /**
     * Create an option element for a kernel name.
     */
    function optionForName(name, displayName) {
        let option = document.createElement('option');
        option.text = displayName;
        option.value = JSON.stringify({ name });
        return option;
    }
    /**
     * Create an option for no kernel.
     */
    function optionForNone() {
        let group = document.createElement('optgroup');
        group.label = 'Use No Kernel';
        let option = document.createElement('option');
        option.text = 'No Kernel';
        option.value = 'null';
        group.appendChild(option);
        return group;
    }
    /**
     * Create an option element for a session.
     */
    function optionForSession(session, displayName) {
        var _a, _b;
        let option = document.createElement('option');
        let sessionName = session.name || PathExt.basename(session.path);
        option.text = sessionName;
        option.value = JSON.stringify({ id: (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id });
        option.title =
            `Path: ${session.path}\n` +
                `Name: ${sessionName}\n` +
                `Kernel Name: ${displayName}\n` +
                `Kernel Id: ${(_b = session.kernel) === null || _b === void 0 ? void 0 : _b.id}`;
        return option;
    }
})(Private || (Private = {}));
//# sourceMappingURL=sessioncontext.js.map